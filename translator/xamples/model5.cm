ESSENCE' 1.0 

$$ using the stps*crates matrix along with the walls, moves and pushes

given n : int
given w : int

given pInit: int
given cInit1 : int
given cInit2 : int

given stps : int

given noWalls : int
given noInvalidMoves : int
given noGoals : int
given noCrates : int

given walls : matrix indexed by [WALLINDICES] of POSITIONS
given invalidMoves : matrix indexed by [INVALIDMOVEINDICES] of MOVES
given goals : matrix indexed by [GOALINDICES] of int(1..n)

letting WALLINDICES be domain int(1..noWalls)
letting INVALIDMOVEINDICES be domain int(1..noInvalidMoves)
letting GOALINDICES be domain int(1..noGoals)
letting CRATEINDICES be domain int(1..noCrates)

letting MOVES be domain int(-w..w)

letting STEPS be domain int(1..stps)

find sokPosn : matrix indexed by [STEPS] of int(1..n)
find move : matrix indexed by [int(1..stps-1)] of MOVES

find crateGoalPosns : matrix indexed by [STEPS,CRATEINDICES] of int(1..n)
such that

sokPosn[1] = pInit,

crateGoalPosns[1,1] = cInit1,
crateGoalPosns[1,2] = cInit2,

forall s : STEPS .
	alldifferent(crateGoalPosns[s]),

forall i : STEPS .

forall wll : WALLINDICES .

	sokPosn[i] != walls[wll],

forall j : int(1..stps-1) .

forall mv : INVALIDMOVEINDICES . 

	(move[j] != invalidMoves[mv]),

forall i : int(1..stps-1) .

	sokPosn[i+1] = (sokPosn[i] + move[i]),
	
forall k : int(1..stps-1) .

((sokPosn[k+1] = crateGoalPosns[k,1]) => (crateGoalPosns[k+1,1] = (crateGoalPosns[k,1] + move[k]))),

forall i : int(1..stps-1) .

((sokPosn[i+1] = crateGoalPosns[i,1]) \/ (crateGoalPosns[i+1,1] = crateGoalPosns[i,1])),

forall k : int(1..stps-1) .

((sokPosn[k+1] = crateGoalPosns[k,2]) => (crateGoalPosns[k+1,2] = (crateGoalPosns[k,2] + move[k]))),

forall i : int(1..stps-1) .

((sokPosn[i+1] = crateGoalPosns[i,2]) \/ (crateGoalPosns[i+1,2] = crateGoalPosns[i,2])),
	
(crateGoalPosns[stps,1] = goals[1]) \/ (crateGoalPosns[stps,1] = goals[2]),
(crateGoalPosns[stps,2] = goals[2]) \/ (crateGoalPosns[stps,2] = goals[1]),

crateGoalPosns[1,1] = crates[1],
crateGoalPosns[1,2] = crates[2]


