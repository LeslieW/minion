\documentclass{article}
%\usepackage{math}
%\pagestyle{fancy}

%\lhead{}
%\chead{Solving Games Symbolically}
%\rhead{\thepage}
%\lfoot{}
%\cfoot{Andrea Rendl}
%\rfoot{}
%\renewcommand{\headrulewidth}{0.4pt}
%\renewcommand{\footrulewidth}{0.4pt}

%%\thispagestyle{plain}

%%\setlength{\oddsidemargin}{0.3in}
%%\setlength{\evensidemargin}{0.3in}

\begin{document}

\title{The Syntax of {\sc Essence}$'$} %Grammar, translated by the {\sc Essence'} $\rightarrow${\sc Minion} translator}

%\author{Alan M. Frisch, Chris Jefferson, Bernadette  Mart\'{\i}nez Hern{\'a}ndez,\\ Ian Miguel, Andrea Rendl} %Andy too?


\date{\today}

\maketitle
%%\begin{center}


{\sc Essence}$'$ is a solver-independent constraint modelling language,
which is a subset of the abstract specification language {\sc Essence}~\cite{essence}. 
Hence {\sc Essence}$'$ can be used to 

\begin{itemize}
\item formulate constraint problem models
\item specify parameter values
\item summarise problem solutions
\end{itemize}

In this document we give the grammar specification of each of these 
different levels that is supported by the {\sc Essence}$'$ translator~\cite{translator}.
Please note that this is not a formal specification of the 
{\sc Essence}$'$ language.


\section{Grammar Specification}

An {\sc Essence}$'$ problem instance 
consists of two separate specifications:
a problem model defining decision variables, domains and constraints, 
and a parameter specification giving parameter values to specify the
problem instance. The solution(s) of a problem instance can then
be summarised by a solution specification. Hence we have three different
types of specifications:

\begin{enumerate}
\item problem model
\item parameter specification
\item solution specification
\end{enumerate}

Before giving a concise context-free grammar for each part, we want to
give an overview of the notation that is used.  


\subsection{Notation}

\begin{itemize}
  \item Terms written in {\it italic font} are non-terminals and terms
  written in {\tt typewriter font} or special characters that 
  are underlined (such as \underline{:} ) are terminals.
  \item Comments are preceded by {\tt \$}, which can be placed everywhere in
the grammar. 
  \item A \textit{letter} is an alphabetic character. An \textit{identifier} is 
    a string whose first character is a \textit{letter} and the rest of its characters 
    are alphanumeric or ``\_''.  Identifier recognition is case sensitive. 

  \item A \textit{number} is any string whose elements are the numeric  characters.
  \item \{$a$\} stands for a non-empty list of $a$s.
  \item \{$a$\}' stands for a non-empty list of $a$s separated by commas.
  \item \{$a$\}* stands for a non-empty list of $a$s separated by the symbol ``*''.
  \item $[a]$ stands for one or zero occurences of $a$.

\end{itemize}



\subsection{Grammar: Problem Model}

\subsubsection{Model}


\begin{tabular}{rcl}

\textit{Model} & ::= & \textit{Header}\\
               &     & [ \textit{ \{Declaration\}}' ] \\
               &     & [ \textit{Objective} ] \\
               &     & [ \texttt{ such that} \{ \textit{Expression} \}' ] \\

 \textit{Header}& ::= & \texttt{ESSENCE}\underline{$'$} \textit{Number} \underline{.} \textit{Number} \\

\textit{Declaration} & ::= & \texttt{given} \{ \textit{Parameter} \}'$\mid$ \\
                     &     & \texttt{where} \{ \textit{Expression} \}' $\mid$ \\
                     &     & \texttt{letting} \{ \textit{Constant} \}' $\mid$\\
                     &     & \texttt{find} \{ \textit{Variable} \}'\\

\textit{Objective} & ::= & \texttt{maximising} \textit{Expression} $\mid$ \\
                   &     & \texttt{minimising} \textit{Expression} \\

\textit{DomainIdentifiers} & ::= & \{ \textit{Identifier} \}' \underline{:} \textit{Domain} \\

\textit{Constant}  & ::=  & \textit{Identifier}  \texttt{be domain} \textit{Domain} $\mid$ \\
                           & & \textit{Identifier} [\underline{:} \textit{Domain} ] \texttt{be} \textit{Expression} \\
%                   &     & \textit{identifier} \texttt{be new type} \textit{userDefType} \\
\textit{Parameter} & ::= & \textit{DomainIdentifiers} \\
%                   &     & \textit{identifier} \texttt{enum} ``\texttt{(...)}'' \\
\textit{Variable}  & ::= & \textit{DomainIdentifiers}\\ 

\end{tabular}

\subsubsection{Domains}
\begin{tabular}{rcl}

\textit{SimpleDomain} & :: & \texttt{bool} $\mid$ \\
                      &    & \texttt{int} \underline{(} \{ \textit{RangeAtom} \}' \underline{)} $\mid$ \\
                      &    & \textit{Identifier} \\
\textit{Domain} & ::= &  \textit{SimpleDomain} $\mid$ \\
                &     & \underline{(} \textit{Domain} \underline{)} $\mid$ \\
                &     & \texttt{matrix indexed by} \underline{[} \{
  \textit{Domain} \}'  \underline{]} \texttt{of} \textit{SimpleDomain} \\ 
\textit{RangeAtom} & ::= & \textit{Expression} $\mid$ \\
                   &     & \textit{Expression} \underline{..} \textit{Expression} \\ 
\textit{IndexRangeAtom} & ::= & \textit{Expression} $\mid$ \\
                   &     & \textit{Expression} \underline{..} \textit{Expression} $\mid$\\ 
                   &     &  \underline{..}\textit{Expression} $\mid$\\ 
                   &     & \textit{Expression} \underline{..} \\ 

\end{tabular}


\subsubsection{Expressions}
\begin{tabular}{rcl}


\textit{Expression} & ::= & \underline{(} \textit{Expression} \underline{)} $\mid$\\
                    &     & \textit{AtomExpression} $\mid$\\
                    &     & \textit{DeRefExpression} $\mid$\\
%                    &     & \textit{groupOpExpression} $\mid$\\
                    &     & \textit{UnaryOpExpression} $\mid$\\
                    &     & \textit{BinaryOpExpression} $\mid$\\
                    &     & \textit{GlobalConstraint} $\mid$\\
                    &     & \textit{QuantifierOpExpression} $\mid$\\

\textit{AtomExpression} & ::= & \textit{Number} $\mid$ \texttt{true} $\mid$ \texttt{false} $\mid$ \textit{Identifier} \\
\textit{DeRefExpression} & ::= & \textit{Identifier} \underline{[} \{ \textit{IndexRangeAtom} \}'  \underline{]} \\
\textit{UnaryOpExpression} & ::= & \underline{-} \textit{Expression} $\mid$ \\
                          &     & \underline{$\mid$} \textit{Expression} \underline{$\mid$} $\mid$ \\
                          &     &  \underline{!} \textit{Expression}\\
\textit{BinaryOpExpression} & ::= & \textit{Expression} \textit{BiOp} \textit{Expression}\\

\textit{BiOp} & ::= & {\tt +} $\mid$ {\tt -}  $\mid$ {\tt /}  $\mid$ {\tt *}  $\mid$  \verb1^1  $\mid$ \\
              &     &  \verb1\/1  $\mid$ \verb1/\1  $\mid$ {\tt =>}  $\mid$ {\tt <=>}  $\mid$ \\
              &     & {\tt =}  $\mid$ {\tt !=}  $\mid$ {\tt <=}  $\mid$ {\tt <}  $\mid$ {\tt >=}  $\mid$ {\tt >} $\mid$ \\
              &     & {\tt <lex} $\mid$ {\tt <=lex} $\mid$ {\tt >lex} $\mid$ {\tt >=lex} \\
\textit{GlobalConstraint} & ::= & \texttt{alldiff}  \underline{(} \textit{Expression}  \underline{)} $\mid$ \\
                              &     & \texttt{element}  \underline{(}
                              \textit{Expression}  \underline{,}
                               \textit{AtomExpression}  \underline{,}
                              \textit{AtomExpression}  \underline{)}  $\mid$\\  
                           %     &     & \texttt{min} ``(``
                           %   \textit{expression},
                           % ``)'' $\mid$ \\  
                           %      &     & \texttt{max} ``(``
                           %   \textit{expression},
                           % ``)'' \\  
      &     &  \texttt{table} \underline{(} \underline{[}\texttt{VariableList}  \underline{]} 
                 \underline{,} \underline{[} \texttt{TupleList} \underline{]} \underline{)} $\mid$ \\ 
%      &     & \texttt{min} ``(`` \textit{expression} ``)'' $\mid$  \texttt{max} ``(`` \textit{expression} ``)'' $\mid$ \\
      &     &  \texttt{atleast} \underline{(}  \texttt{Expression}   \underline{,} \texttt{ConstantList}  \underline{,}  \texttt{ConstantList}  \underline{)} $\mid$ \\ 
&     &  \texttt{atmost}  \underline{(}  \texttt{Expression} \underline{,} \texttt{ConstantList} \underline{,}  \texttt{ConstantList}  \underline{)} \\


 \textit{QuantifierOpExpression} & ::= & \textit{Quantifier} \textit{BindingExpression} ``.'' \textit{Expression} \\
\textit{Quantifier} & ::= & \texttt{forall} $\mid$ \texttt{exists} $\mid$ \texttt{sum} \\ 
\textit{BindingExpression} & ::= & \{ \textit{Identifier} \}' \underline{:} \textit{SimpleDomain} \\




\end{tabular}


\subsubsection{Further Restrictions}

\begin{itemize}
\item Quantifications may not range over decision variables, i.e. {\it
  BindingExpression}s may not contain decision variables
\end{itemize}



\subsection{Grammar: Parameter Specification}

\begin{tabular}{rcl}
\textit{ParameterSpecification} & ::= & \textit{Header}\\
               &     & [ \textit{ \{Declaration\}}' ] \\

 \textit{Header}& ::= & \texttt{ESSENCE}\underline{$'$} \textit{Number} \underline{.} \textit{Number} \underline{.} \textit{Number} \\
 \textit{Declaration} & ::=    & \texttt{param} \{ \textit{Constant} \}' \\
 \textit{Constant}  & ::=  & \textit{Identifier}  \texttt{be domain} \textit{Domain} $\mid$ \\
                           & & \textit{Identifier}  \texttt{be} \textit{ConstantExpression} \\


\textit{ConstantExpression} & ::= & \textit{Number} $\mid$ \texttt{true} $\mid$ \texttt{false}  \\
\textit{ConstantDomain} & :: & \texttt{bool} $\mid$ \\
                      &    & \texttt{int} \underline{(} \{ \textit{RangeAtom} \}' \underline{)} \\
\textit{RangeAtom} & ::= & \textit{ConstantExpression} $\mid$ \\
                   &     & \textit{ConstantExpression} \underline{..} \textit{ConstantExpression} \\ 

\end{tabular}



\subsection{Grammar: Solution Specification}

\begin{tabular}{rcl}
\textit{SolutionSpecification} & ::= & \textit{Header}\\
                               &     & [ \textit{ \{Solution\}}' ] \\

 \textit{Header}& ::= & \texttt{ESSENCE}\underline{$'$} \textit{Number} \underline{.} \textit{Number} \\
 \textit{Solution} & ::=    & \texttt{variable} {\it Identifier} {\tt is} \{ \textit{SolutionExpression}\}' \\
 \textit{SolutionExpression}  & ::=  & \textit{Number} $\mid$ \\
                           & &  \textit{ConstantArray} $\mid$\\


\textit{ConstantArray} & ::= & \underline{[} \{ \textit{Number} \}'  \underline{]} $\mid$ \\
                       &     & \underline{[} \{ \textit{ConstantArray} \}'  \underline{]}  \\


\end{tabular}


%\clearpage

\section{Operator Precedence}

Table 1 %\ref{tab:precedence} 
describes the precedence of the operators that 
are arranged by decreasing order of precedence (the operators on top have highest precedence)


\begin{table}


    
    \begin{center}
    \begin{tabular}{|l|lc|}
 
      \hline
       Operator & Functionality & Associativity \\
       \hline
       \hline
       ,   & comma & Left \\   
       \hline
       :   & colon & Left \\
       \hline
       ( ) & left and right parenthesis & Left \\
       \hline
       \verb1[ ]1 & left and right brackets & Left \\
       \hline
       ! & not & Right \\  
       \hline
       \verb1/\1 & and & Left \\ 
       \hline
       \verb1\/1 & or & Left \\ 
       \hline
        {\tt =>} & if (implication)  & Left \\ 
	\hline
        {\tt <=>} & iff (logical equality) & Left \\ 
	\hline
        {\tt -} & unary minus & Right \\
	\hline
        \verb1^1 & power & Left \\ 
	\hline
        * / & multiplication, integer division & Left \\ 
	\hline
        {\tt + -} & addition, substraction &  Left \\
	\hline
        {\tt < <= > >= } & (lex)less, (lex)less or equal, &  \\ 
	{\tt <lex <=lex >lex >=lex } & (lex)greater, (lex)greater or equal & none \\ 
	\hline
        {\tt = !=} & equality, disequality & none \\
	\hline
        . & dot & Right \\ 
	\hline

      \end{tabular}\label{tab:precedence}
\end{center}
    \caption{Operator precedence in {\sc Essence}$'$}


\end{table}


\section{Examples}


To illustrate the grammar specified above, we give some examples.
These examples can be found with the {\sc Essence}$'$ translator
which is available with Minion\footnote{http://minion.sourceforge.net/}.

\subsection{N-Queens}

We start with the well-known n-queens problem  which is to place $n$
queens on an $n \times n$ chessboard. The problem model states 
the problem class, as given as follows:

\begin{center}
\begin{tabular}{|l|}
\hline
{\bf {\em N-Queens} problem model} \\
\hline 
\hline
{\tt ESSENCE' 1.0} \\
\\
{\tt given \ \ \ \ \ n : int(1...)}\\
{\tt letting \ \ \ INDEX be domain int(1..n) } \\
{\tt find \ \ \ \ \ \ f : matrix indexed by [ INDEX ] of INDEX } \\
\\
{\tt such that  \ alldifferent(f),	   }\\
 \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ {\tt forall i,j : INDEX .  } \\
 \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ {\tt (i > j) => }\\ 
 \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  {\tt ((f[i] - i != f[j] - j) } \\
 \ \ \ \ \ \ \ \ \ \ \ \ \ \  \ \ \ \ \ \ \ \  {\tt  /\verb1\1 (f[i] + i != f[j] + j)) } \\
 \\
\hline
\end{tabular}
\end{center}

To solve a problem instance of the n-queens problem, we need to give a 
value for the parameter $n$. We do this in the parameter specification:

\begin{center}
\begin{tabular}{|l|}
\hline
{\bf {\em N-Queens} parameter specification} \\
\hline 
\hline
{\tt ESSENCE' 1.0} \\
{\tt param \ \ \ \ \ n be 8 \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
   \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  }\\
\hline
\end{tabular}
\end{center}

After giving both problem model and parameter specification to a
solver, for instance using the {\sc Essence}$'$ translator, you 
will be given a solution, such as 


\begin{center}
\begin{tabular}{|l|}
\hline
{\bf {\em N-Queens} solution specification} \\
\hline 
\hline
{\tt ESSENCE' 1.0} \\
{\tt var \ \ \ \ \ f is [0, 2, 1, 4, 3, 6, 7, 5] \ \ \ \ \ \ \ \ \ \ \ \ \ \ \   }\\
\hline
\end{tabular}
\end{center}




\begin{thebibliography}{10}
\scriptsize
\bibitem{essence}
A.M. Frisch, M.~Grum, C.~Jefferson, B.~Mart\'{\i}nez~Hern{\'a}ndez, and
  I.~Miguel.
\newblock The design of essence: A constraint language for specifying
  combinatorial problems.
\newblock In {\em IJCAI}, pp 80--87, 2007.


\bibitem{translator}
I.P. Gent, I. Miguel and A. Rendl.
\newblock Tailoring Solver-independet Constraint Models: A Case Study with Essence$'$ and Minion
\newblock In {\em SARA}, 2007.


\bibitem{minion}
I.P. Gent, C.~Jefferson, and I.~Miguel.
\newblock Minion: A fast scalable constraint solver.
\newblock In {\em ECAI}, pp 98--102, 2006.



\end{thebibliography}

\end{document}
