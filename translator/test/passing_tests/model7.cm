ESSENCE' 1.0 

$$ using the stps*crates matrix along with the walls, moves and pushes

given n : int
given w : int

given pInit: int
given cInit1 : int
given cInit2 : int

given stps : int

given noWalls : int
given noInvalidMoves : int
given noGoals : int
given noCrates : int

given walls : matrix indexed by [WALLINDICES] of POSITIONS
given invalidMoves : matrix indexed by [INVALIDMOVEINDICES] of MOVES
given goals : matrix indexed by [GOALINDICES] of int(1..n)
given crates : matrix indexed by [CRATEINDICES] of int(1..n)

letting WALLINDICES be domain int(1..noWalls)
letting INVALIDMOVEINDICES be domain int(1..noInvalidMoves)
letting GOALINDICES be domain int(1..noGoals)
letting CRATEINDICES be domain int(1..noCrates)

letting MOVES be domain int(-w..w)

letting STEPS be domain int(1..stps)

find sokPosn : matrix indexed by [STEPS] of int(1..n)
find move : matrix indexed by [int(1..stps-1)] of MOVES

find crateGoalPosns : matrix indexed by [STEPS,CRATEINDICES] of int(1..n)

such that

$$ initialization of the porter's and the crates' positions

sokPosn[1] = pInit,

forall ck : int(1..noCrates) .

crateGoalPosns[1,ck] = crates[ck],

$crateGoalPosns[1,1] = crates[1],
$crateGoalPosns[1,2] = crates[2],

forall s : STEPS .
	alldifferent(crateGoalPosns[s]),

forall i : STEPS .

forall wll : WALLINDICES .

	sokPosn[i] != walls[wll],

forall j : int(1..stps-1) .

forall mv : INVALIDMOVEINDICES . 

	(move[j] != invalidMoves[mv]),

forall i : int(1..stps-1) .

	sokPosn[i+1] = (sokPosn[i] + move[i]),
	
forall k : int(1..stps-1) .
forall c : CRATEINDICES .

((sokPosn[k+1] = crateGoalPosns[k,c]) 
		=> (crateGoalPosns[k+1,c] = (crateGoalPosns[k,c] + move[k]))),

forall i : int(1..stps-1) .
forall c : CRATEINDICES .

((sokPosn[i+1] = crateGoalPosns[i,c]) \/ 
		(crateGoalPosns[i+1,c] = crateGoalPosns[i,c])),

forall c : CRATEINDICES .	

exists g : GOALINDICES .

crateGoalPosns[stps,c] = goals[g]


