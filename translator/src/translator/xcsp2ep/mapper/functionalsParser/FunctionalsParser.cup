/*
CUP Parser Generator Copyright Notice, License, and Disclaimer
Copyright 1996-1999 by Scott Hudson, Frank Flannery, C. Scott Ananian

Permission to use, copy, modify, and distribute this software and its
 documentation for any purpose and without fee is hereby granted,
 provided that the above copyright notice appear in all copies and
 that both the copyright notice and this permission notice and
 warranty disclaimer appear in supporting documentation, and that the
 names of the authors or their employers not be used in advertising or
 publicity pertaining to distribution of the software without
 specific, written prior permission.

The authors and their employers disclaim all warranties with regard to 
this software, including all implied warranties of merchantability and 
fitness. In no event shall the authors or their employers be liable
for any special, indirect or consequential damages or any damages
whatsoever resulting from loss of use, data or profits, whether in an 
action of contract, negligence or other tortious action, arising out
of or in connection with the use or performance of this software.
This is an open source license. It is also GPL-Compatible (see entry 
for "Standard ML of New Jersey"). The portions of CUP output which are
 hard-coded into the CUP source code are (naturally) covered by this
 same license, as is the CUP runtime code linked with the generated parser.

Java is a trademark of Sun Microsystems, Inc. References to the Java
 programming language in relation to JLex are not meant to imply that 
Sun endorses this product. 
*/

package translator.xcsp2ep.mapper.functionalsParser;

import	translator.expression.*;
import java.util.LinkedList;


parser code {:

     public StringBuffer errorMessage = new StringBuffer("");

    /* The reason for the error is passed into the method in the
       String 'message'. */

    public void report_error(String message, Object info)  {

        StringBuffer m = new StringBuffer("Parse error:");


        if (info instanceof java_cup.runtime.Symbol) {
                java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);
            if (s.left >= 0) {
                                m.append(" in line "+(s.left));
                if (s.right >= 0)
                        m.append(", column "+(s.right));
            }
        }
        m.append(" : "+message);
        //throw new Exception(m);
        errorMessage = m;
        System.err.println(m);
    }

    public void report_fatal_error(String message, Object info)  {
        report_error(message, info);
        //System.exit(1);
    }



:};

action code {:

        public int errors_found = 0;
       

:}



/* Terminals (tokens returned by scanner) */

/* keywords */
terminal	   	ABS, ADD, AND, DIV, EQ;
terminal 		FALSE, GE, GT, IF, IFF, LE, LT;
terminal 		MAX, MIN, MOD, MUL, NE, NEG, NOT;
terminal 		OR, POW, SUB, TRUE, UMINUS, XOR;	 


/* separators  */
terminal	   LPAREN, RPAREN, COMMA;


terminal String    IDENTIFIER;
terminal Integer   INTEGER;



/* Non-terminals */

non terminal functional, booleanExpression, integerExpression; 




/* NO Precedences */





/* functional's grammar */


functional ::= booleanExpression:e
	           {: RESULT = (RelationalExpression) e; :}
;

booleanExpression ::=     	FALSE {: RESULT = new RelationalAtomExpression(false); :}						
                        |  	TRUE  {: RESULT = new RelationalAtomExpression(true); :}
                        	
                        |   NOT LPAREN booleanExpression:b RPAREN
                            {: RESULT = new Negation((RelationalExpression) b);  :}
                             
                        |   AND LPAREN booleanExpression:b1 COMMA booleanExpression:b2 RPAREN
                        	{: RESULT = new Conjunction(new Expression[] 
                        	                                     { (Expression) b1,
                        	                                       (Expression) b2}); :}
                        
                        |   OR  LPAREN booleanExpression:b1 COMMA booleanExpression:b2 RPAREN
                        	{: RESULT = new Disjunction(new RelationalExpression[] 
                        	                                     { (RelationalExpression) b1,
                        	                                       (RelationalExpression) b2}); :}
                        
                        |   XOR LPAREN booleanExpression:b1 COMMA booleanExpression:b2 RPAREN
                            {: RESULT = new CommutativeBinaryRelationalExpression
                                             ( (Expression) b1,
                                                Expression.NEQ,
                        	                   (Expression) b2
                        	                  ); :}
                        
                        |   IFF LPAREN booleanExpression:b1 COMMA booleanExpression:b2 RPAREN
						    {: RESULT = new CommutativeBinaryRelationalExpression
                                             ( (RelationalExpression) b1,
                                                Expression.EQ,
                        	                   (RelationalExpression) b2
                        	                  ); :}                        
                        
                        |   EQ  LPAREN integerExpression:b1 COMMA integerExpression:b2 RPAREN
						    {: RESULT = new CommutativeBinaryRelationalExpression
                                             ( (Expression) b1,
                                                Expression.EQ,
                        	                   (Expression) b2
                        	                  ); :}       
                        	                                          
                        |   NE  LPAREN integerExpression:b1 COMMA integerExpression:b2 RPAREN
                            {: RESULT = new CommutativeBinaryRelationalExpression
                                             ( (Expression) b1,
                                                Expression.NEQ,
                        	                   (Expression) b2
                        	                  ); :}
                        	                                          
                        |   GE  LPAREN integerExpression:b1 COMMA integerExpression:b2 RPAREN
                            {: RESULT = new NonCommutativeRelationalBinaryExpression
                                             ( (Expression) b1,
                                                Expression.GEQ,
                        	                   (Expression) b2
                        	                  ); :}                        
                        
                        |   GT  LPAREN integerExpression:b1 COMMA integerExpression:b2 RPAREN
                            {: RESULT = new NonCommutativeRelationalBinaryExpression
                                             ( (Expression) b1,
                                                Expression.GREATER,
                        	                   (Expression) b2
                        	                  ); :}                        
                        
                        |   LE  LPAREN integerExpression:b1 COMMA integerExpression:b2 RPAREN
                            {: RESULT = new NonCommutativeRelationalBinaryExpression
                                             ( (Expression) b1,
                                                Expression.LEQ,
                        	                   (Expression) b2
                        	                  ); :}    
                        	                                          
                        |   LT  LPAREN integerExpression:b1 COMMA integerExpression:b2 RPAREN
                            {: RESULT = new NonCommutativeRelationalBinaryExpression
                                             ( (Expression) b1,
                                                Expression.LESS,
                        	                   (Expression) b2
                        	                  ); :}                      
                        
;                        
                        
integerExpression ::= 	  INTEGER:i 
						  {: RESULT = new ArithmeticAtomExpression(i); :}
						  
						| UMINUS INTEGER:i
						  {: RESULT = new ArithmeticAtomExpression(-i); :} 
						  
          				| IDENTIFIER:varName 
          				  {:  RESULT = new ArithmeticAtomExpression(new SimpleVariable(varName)); :}
          				  
          				| UMINUS IDENTIFIER:varName
          				  {:  RESULT = new UnaryMinus(new ArithmeticAtomExpression(new SimpleVariable(varName))); :}  
          				  
          				| NEG  LPAREN integerExpression:e RPAREN
          				  {:  RESULT = new Negation( (Expression) e); :}
          				   
          				| ABS  LPAREN integerExpression:e RPAREN 
          				  {: RESULT = new AbsoluteValue( (Expression) e); :}
          				
          				| ADD  LPAREN integerExpression:e1 COMMA integerExpression:e2 RPAREN
          				  {: RESULT = new Sum( new Expression[] { (Expression) e1,
          				                                          (Expression) e2 
          				                                         },
          				                       new Expression[] {}
          				                     );   :}
          				
          				| SUB  LPAREN integerExpression:e1 COMMA integerExpression:e2 RPAREN
          				  {: RESULT = new Sum( new Expression[] { (Expression) e1 },
          				                       new Expression[] { (Expression) e2 }
          				                     );   :}
          				                     
          				| MUL  LPAREN integerExpression:e1 COMMA integerExpression:e2 RPAREN
          				  {: RESULT = new Multiplication( new Expression[] { (Expression) e1,
          				                                                     (Expression) e2 }
          				                                  );   :}
          				
          				| DIV  LPAREN integerExpression:e1 COMMA integerExpression:e2 RPAREN
          				  {: RESULT = new NonCommutativeArithmeticBinaryExpression
                                             ( (Expression) e1,
                                                Expression.DIV,
                        	                   (Expression) e2
                        	                  ); :}   
          				
          				| MOD  LPAREN integerExpression:e1 COMMA integerExpression:e2 RPAREN
          				{: RESULT = new NonCommutativeArithmeticBinaryExpression
                                             ( (Expression) e1,
                                                Expression.MOD,
                        	                   (Expression) e2
                        	                  ); :} 
          				
          				| POW  LPAREN integerExpression:e1 COMMA integerExpression:e2 RPAREN
          				{: RESULT = new NonCommutativeArithmeticBinaryExpression
                                             ( (Expression) e1,
                                                Expression.POWER,
                        	                   (Expression) e2
                        	                  ); :} 
          				
          				| MIN  LPAREN integerExpression:e1 COMMA integerExpression:e2 RPAREN
	                    {: 
	                       boolean isMaximum = false;
          				   AtomExpression leftArgument = null;
          				   AtomExpression rightArgument = null;
          				   
          				   try {
          				   
          				   if(e1 instanceof AtomExpression)
          				    	leftArgument = (AtomExpression) e1;
          				   else throw new Exception("Cannot translate Minimum Constraint with non-atomic argument:"+e1);
          				   
          				   if(e2 instanceof AtomExpression)
          				   	    rightArgument = (AtomExpression) e2;
          				   else throw new Exception("Cannot translate Minimum Constraint with non-atomic argument:"+e2);
          				   
          				   } catch(Exception e) {
          				   	  e.printStackTrace(System.out);
          				   	  System.exit(1);
          				   }
          				   
          				   	
          				   RESULT = new Minimum
                                             ( new VariableArray( new AtomExpression[]  { leftArgument,
                        	                                                              rightArgument } ),
                        			           isMaximum                   
                        	                  ); 
                          :}  
	                    
	      
	                      /* RESULT = new CommutativeBinaryRelationalExpression
                                             ( (Expression) e1,
                                                Expression.MIN,
                        	                   (Expression) e2
                        	                  ); :} */          				
          				
          				| MAX  LPAREN integerExpression:e1 COMMA integerExpression:e2 RPAREN
          				{: 
          				   boolean isMaximum = true;
          				   AtomExpression leftArgument = null; 
          				   AtomExpression rightArgument = null;
          				   
          				   try {
          				    
          				     if(e1 instanceof AtomExpression)
          				    	leftArgument = (AtomExpression) e1;
          				     else throw new Exception("Cannot translate Maximum Constraint with non-atomic argument:"+e1);
          				   
          				     if(e2 instanceof AtomExpression)
          				   	    rightArgument = (AtomExpression) e2;
          				     else throw new Exception("Cannot translate Maximum Constraint with non-atomic argument:"+e2);
          				   
          				   } catch(Exception e) {
          				   	  e.printStackTrace(System.out);
          				   	  System.exit(1);
          				   }
          				   
          				   	
          				   RESULT = new Minimum
                                             ( new VariableArray( new AtomExpression[]  { leftArgument,
                        	                                                              rightArgument } ),
                        			           isMaximum                   
                        	                  ); 
                          :}  
          				
          				| IF   LPAREN booleanExpression:e1 COMMA integerExpression:e2 COMMA integerExpression:e3 RPAREN
                        {: 
                            /*RelationalExpression first = new NonCommutativeRelationalBinaryExpression
                                             ( (Expression) e1,
                                                Expression.IF,
                        	                   (Expression) e2
                        	                  );  
                        
                        	RelationalExpression second = new NonCommutativeRelationalBinaryExpression
                                             ( new Negation((Expression) e1),
                                                Expression.IF,
                        	                   (Expression) e3
                        	                  );
                        
                        
                           RESULT = new Conjunction
                                             ( new Expression[] {first, second} ); 
                        	                  
                        	                  
                           //RESULT = new ArithmeticAtomExpression(0);	
                           
                           // for solver competition
                           //System.out.println("s UNKNOWN");
                           //System.exit(0);                  

                        	  */
                        	 System.out.println("s UNKNOWN");
                        	 System.exit(0);                 
                        	      :}  

 ;                       