/*
CUP Parser Generator Copyright Notice, License, and Disclaimer
Copyright 1996-1999 by Scott Hudson, Frank Flannery, C. Scott Ananian

Permission to use, copy, modify, and distribute this software and its
 documentation for any purpose and without fee is hereby granted,
 provided that the above copyright notice appear in all copies and
 that both the copyright notice and this permission notice and
 warranty disclaimer appear in supporting documentation, and that the
 names of the authors or their employers not be used in advertising or
 publicity pertaining to distribution of the software without
 specific, written prior permission.

The authors and their employers disclaim all warranties with regard to 
this software, including all implied warranties of merchantability and 
fitness. In no event shall the authors or their employers be liable
for any special, indirect or consequential damages or any damages
whatsoever resulting from loss of use, data or profits, whether in an 
action of contract, negligence or other tortious action, arising out
of or in connection with the use or performance of this software.
This is an open source license. It is also GPL-Compatible (see entry 
for "Standard ML of New Jersey"). The portions of CUP output which are
 hard-coded into the CUP source code are (naturally) covered by this
 same license, as is the CUP runtime code linked with the generated parser.

Java is a trademark of Sun Microsystems, Inc. References to the Java
 programming language in relation to JLex are not meant to imply that 
Sun endorses this product. 
*/

package translator.essencePrimeParser;

//import translator.conjureEssenceSpecification.*;
//import java.util.LinkedList;


import translator.expression.*;
import java.util.ArrayList;

action code {:

	public boolean hadErrorRecovery = false;
     public StringBuffer errorMessage = new StringBuffer("");

    /* The reason for the error is passed into the method in the
       String 'message'. */

    public void report_error(String message, Object info)  {

        StringBuffer m = new StringBuffer("Parse error:");


        if (info instanceof java_cup.runtime.Symbol) {
                java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);
            if (s.left >= 0) {
                                m.append(" in line "+(s.left));
                if (s.right >= 0)
                        m.append(", column "+(s.right));
            }
        }
        m.append(" : "+message);
        //throw new Exception(m);
        errorMessage = m;
        System.err.println(m);
    }


	

:}


parser code {:

	 public boolean hadErrorRecovery = false;
     public StringBuffer errorMessage = new StringBuffer("");

    /* The reason for the error is passed into the method in the
       String 'message'. */

    public void report_error(String message, Object info)  {

        StringBuffer m = new StringBuffer("Parse error:");


        if (info instanceof java_cup.runtime.Symbol) {
                java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);
            if (s.left >= 0) {
                                m.append(" in line "+(s.left));
                if (s.right >= 0)
                        m.append(", column "+(s.right));
            }
            m.append(" : "+message);
        }
        else m.append(" "+message);
        //throw new Exception(m);
        errorMessage = m;
        System.err.println(m);
    }

    public void report_fatal_error(String message, Object info)  {
        report_error(message, info);
        //System.exit(1);
    }
    
    public void setErrorRecovery(boolean on) {
    	hadErrorRecovery = on;
    	//System.out.println("Error recovery on?:"+hadErrorRecovery);
    }
   
   /* 
    public boolean hadErrorRecovery() {
    	if(this.action_obj!= null)
    		return this.action_obj.hadErrorRecovery;
    	else return false;
    }
    
    public StringBuffer getActionErrorMessage() {
    	if(action_obj != null)
			return this.action_obj.errorMessage;
		else return new StringBuffer("");
	}
	*/

:};

//action code {:

//        public int errors_found = 0;
       

//:}



/* Terminals (tokens returned by scanner) */

/* keywords */
terminal	   ALLDIFF, ATLEAST, ATMOST;
terminal	   BE, BE_DOMAIN, BE_NEW_TYPE;
terminal	   ENUM, EXISTS, ELEMENT, FALSE, FIND, FORALL;
terminal 	   GIVEN, HEADER, INT, LETTING, MATRIX_INDEXED_BY;
terminal	   MAXIMISING, MAX, MINIMISING, MIN, MODULO;
terminal 	   OCCURRENCE, OF, SUCH_THAT, SUM, TABLE; 
terminal            TRUE, WHERE;


/* separators  */
terminal	   LPAREN, RPAREN, LBRACK, RBRACK;
terminal	   DOT, DOTDOT, COMMA, COLON, BAR;

/* operators */
terminal 	   EQ, NEQ, LESS, LEQ, GREATER, GEQ;
terminal	   PLUS, MINUS, MULT, DIVISION, POWER, UMINUS;
terminal 	   AND, OR, NOT, IF, IFF;
terminal       LEXLESS, LEXGREATER, LEXLEQ, LEXGEQ;


terminal String    IDENTIFIER;
terminal Integer   INTEGER;



/* Non-terminals */

non terminal essencemodel, body;
non terminal declarations, declaration_list, declaration, objective, constraint_block;
non terminal given_block, where_block, letting_block, find_block;
non terminal variable_declaration_list, infinite_variable_declaration_list;
non terminal identifiers_with_domain, identifiers_with_infinite_domain, identifier_list;
non terminal domain, domain_list, infinite_domain;
non terminal expression, expression_list;
non terminal atomic_expression, deref_expression, atom_expression;
non terminal index, index_list;
non terminal unary_expression, binary_expression, lex_expression,  global_constraint;
non terminal quantified_expression, variable_array;
non terminal table_constraint, atom_list, integer_list;
non terminal constant_vector_list, constant_vector, constant_matrix;
non terminal user_def_type;




/* Precedences (according to "The Syntax of ESSENCE" paper) 
   the operators on top have the lowest precedence  */

precedence right DOT;
precedence nonassoc EQ, NEQ;
precedence nonassoc LESS, LEQ, GREATER, GEQ, LEXLESS, LEXLEQ, LEXGEQ, LEXGREATER; 
precedence left PLUS, MINUS;
precedence left MULT, DIVISION, MODULO;
precedence left POWER;
precedence right UMINUS;
precedence left IFF;
precedence left IF;
precedence left OR;
precedence left AND;
precedence right NOT;
precedence left LBRACK, RBRACK;
precedence left LPAREN, RPAREN;
precedence left COLON;
precedence left COMMA;





/* Essence' grammar */


essencemodel ::= HEADER body:b
		{: RESULT = (EssencePrimeModel) b; :}
		
;


body ::= 	declarations:d_list 
	        objective:obj 
                constraint_block:expr_list 

         	{: 
		       RESULT = new EssencePrimeModel(
						   (ArrayList<GeneralDeclaration>) d_list,
						   (Objective)  obj,
						   (ArrayList<Expression>)expr_list 
                                               ); 
                :} 
						   
		    	
		    			   
 ;






/* General Declarations  */

declarations ::=	 declaration_list:d 
				{: RESULT = d; :} 	
	
			| /* epsilon */ 
			  {:	  RESULT = new ArrayList<GeneralDeclaration>(); :}
;		


declaration_list ::=      declaration:d
				{: RESULT = d; :}

  			| declaration:d1 declaration_list:d2
				{: 
					ArrayList<GeneralDeclaration> list1 = (ArrayList<GeneralDeclaration>) d1; 
					ArrayList<GeneralDeclaration> list2 = (ArrayList<GeneralDeclaration>) d2; 
					
					if(list1.size() > list2.size()) {
					   
					   for(int i=list2.size()-1; i>=0; i--) {
					   	   list1.add(0,list2.get(i));
					   }
					   RESULT = list1;	
					}
					
					else {
					
					   for(int i=list1.size()-1; i>=0; i--) {
					   	   list2.add(0,list1.get(i));
					   }
					   RESULT = list2;	
				    }
                :} 
;
 

declaration ::=  given_block:d
		    {: RESULT = (ArrayList<GeneralDeclaration>) d; :}
	
	         | where_block:d
		    {:
		      ArrayList<GeneralDeclaration> list = new ArrayList<GeneralDeclaration>();
		      list.add((ConstantRestriction)  d);
		      RESULT = list; 
		     :}

		 | letting_block:d
		    {: ArrayList<GeneralDeclaration> list = new ArrayList<GeneralDeclaration>();
		      list.add((GeneralDeclaration)  d);
		      RESULT = list;
		     :}

		 | find_block:d
		    {: RESULT =(ArrayList<GeneralDeclaration>)  d; :}

;
	
	

 
 
given_block ::= GIVEN variable_declaration_list:list
	        {:  
		   		ArrayList<VariableDeclaration> parameters =(ArrayList<VariableDeclaration>) list;		   
		   		ArrayList<GeneralDeclaration> declarations = new ArrayList<GeneralDeclaration>();
		   		   
                for(int i=0; i<parameters.size(); i++) {
		      	    declarations.add(new ParameterDeclaration(parameters.get(i).getNames(),
		      	    										  parameters.get(i).getDomain()
		      	    										  )
		      	    	             );
                }		       		   

		        RESULT = declarations; 

		    :}
		    
		   | GIVEN infinite_variable_declaration_list:list
	        {:  
		   		ArrayList<VariableDeclaration> parameters =(ArrayList<VariableDeclaration>) list;		   
		   		ArrayList<GeneralDeclaration> declarations = new ArrayList<GeneralDeclaration>();
		   		   
                for(int i=0; i<parameters.size(); i++) {
		      	    declarations.add(new ParameterDeclaration(parameters.get(i).getNames(),
		      	    										  parameters.get(i).getDomain()
		      	    										  )
		      	    				);
                }		       		   

		        RESULT = declarations; 

		    :}												

;


where_block ::= WHERE expression_list:e_list 
               	        {:
			              RESULT = new ConstantRestriction((ArrayList<Expression>) e_list);  
		                :}
;




letting_block ::= LETTING IDENTIFIER:id BE expression:e 
	        {: 
		   RESULT = new ExpressionDefinition((String) id,
                                                      (Expression) e);

                :}

	    | LETTING IDENTIFIER:id COLON domain:d BE expression:e
		{: 
		   RESULT = new ExpressionDefinition((String) id,
						      (Expression) e,
						      (Domain) d);
		:}
                
                
                
        | LETTING IDENTIFIER:id BE_DOMAIN domain:d     
		{: 
		  RESULT = new DomainDefinition( (String) id,
					         (Domain) d);
		:}
	
	
	    | LETTING IDENTIFIER:id BE constant_vector:cv
	    {: 
	      ArrayList<Integer> i_list = (ArrayList<Integer>) cv;
	      Integer[] i_array = new Integer[i_list.size()];
	      for(int i=i_array.length-1; i>=0; i--)
	      	i_array[i] = i_list.remove(i);
	      
	      RESULT = new ExpressionDefinition( (String) id,
	                                          new ConstantVector( (String) id,
	                                                              i_array)
	                                       );
	    
	    :}
	    
	    | LETTING IDENTIFIER:id COLON domain:d BE constant_vector:cv
	    {: 
	      ArrayList<Integer> i_list = (ArrayList<Integer>) cv;
	      Integer[] i_array = new Integer[i_list.size()];
	      for(int i=i_array.length-1; i>=0; i--)
	      	i_array[i] = i_list.remove(i);
	      
	      RESULT = new ExpressionDefinition( (String) id,
	                                          new ConstantVector( (String) id,
	                                                              i_array,
	                                                              (Domain) d)
	                                       );
	    
	    :}
		
		
		| LETTING IDENTIFIER:id BE constant_matrix:constant_matrix 
		{: 
		  RESULT = new ExpressionDefinition( (String) id,
		                                      new ConstantMatrix( (String) id,
		                                                          (Integer[][]) constant_matrix
		                                                         )
		                                   );
		                                                          
		:}
		
		| LETTING IDENTIFIER:id COLON domain:d BE constant_matrix:constant_matrix 
		{: 
		  RESULT = new ExpressionDefinition( (String) id,
		                                      new ConstantMatrix( (String) id,
		                                                          (Integer[][]) constant_matrix,
		                                                           (Domain) d
		                                                         )
		                                   );
		                                                          
		:}
	
				
;




find_block ::= 	FIND variable_declaration_list:v_list
	       {:  
	          RESULT = v_list;
	       :}
;



/*  Objective */



objective ::= 	  MAXIMISING expression:e
			      {: 
			         boolean isMaximising = true;
			         RESULT = new Objective((Expression) e, isMaximising); 
			       :}

		        | MINIMISING expression:e
			      {: 
 	                 boolean isMaximising = false;
			         RESULT = new Objective((Expression) e, isMaximising); 
			       :}
			       
		        | /* epsilon */
			       {:    
			         RESULT = new Objective(); 
			       :}
;


/*  Constraints */

constraint_block ::=     SUCH_THAT expression_list:e_list 
			  {: RESULT = e_list; :}
		        | /* epsilon */
			  {:
		            RESULT = new ArrayList<Expression>(); :}	
;




/* Rest */

variable_declaration_list ::=   identifiers_with_domain:id
		     {: 
			    ArrayList<VariableDeclaration> list = new ArrayList<VariableDeclaration>();
			    list.add( (VariableDeclaration) id);
			     RESULT = list;  
			  :}
					   
		  | identifiers_with_domain:di COMMA variable_declaration_list:di_list
		     {: 
		         ((ArrayList<VariableDeclaration>) di_list).add(0,(VariableDeclaration) di);  
			     RESULT = di_list; 
			 :}
;



infinite_variable_declaration_list ::= identifiers_with_infinite_domain:id
		     {: 
			    ArrayList<VariableDeclaration> list = new ArrayList<VariableDeclaration>();
			    list.add( (VariableDeclaration) id);
			     RESULT = list;  
			  :}
					   
		  | identifiers_with_infinite_domain:di COMMA variable_declaration_list:di_list
		     {: 
		         ((ArrayList<VariableDeclaration>) di_list).add(0,(VariableDeclaration) di);  
			     RESULT = di_list; 
			 :}
;




identifiers_with_domain ::= identifier_list:id_list COLON domain:d
			{: 
				RESULT = new VariableDeclaration((ArrayList<String>) id_list,
										         (Domain) d);
			 :}
;



identifiers_with_infinite_domain ::= identifier_list:id_list COLON infinite_domain:d
			{: 
			   boolean isParameter = true; /* only parameters are allowed to have infinte domains*/
			   RESULT = new VariableDeclaration((ArrayList<String>) id_list,
										         (Domain) d,
										          isParameter);
             :}
;



infinite_domain ::= 
                   INT LPAREN expression:e DOTDOT RPAREN
                     {: 
                        boolean isLowerBound = true;
                        RESULT = new InfiniteDomain((Expression) e, isLowerBound); 
                      :}
                      
                  | INT LPAREN DOTDOT expression:e RPAREN
                   {: 
                       boolean isLowerBound = false;
                        RESULT = new InfiniteDomain((Expression) e, isLowerBound); 
                   :}     
                      
                  |
                    INT LPAREN RPAREN
                     {: RESULT = new InfiniteDomain();
                     :} 
                  |
                     INT LPAREN DOTDOT RPAREN
                     {: RESULT = new InfiniteDomain(); :} 
                  |
                   INT
                     {: RESULT = new InfiniteDomain(); :} 
;


identifier_list ::=	  IDENTIFIER:id
				   {: 	
			           ArrayList<String> list = new ArrayList<String>();
				       list.add(0,new String(id));
				       RESULT = list; 
				   :}

			       | IDENTIFIER:id COMMA identifier_list:id_list
				   {: 
				       ((ArrayList<String>) id_list).add(0,new String(id)); 
				       RESULT = id_list; 
				   :}
;



/*   Domain */

domain ::= 	LPAREN domain:d RPAREN	     
			{: RESULT = (Domain) d; :}

	      | IDENTIFIER:id
			{: if(id.equals("bool") || id.equals("BOOL")) 
			     RESULT = new BoolDomain();
			     
	           else 
			     RESULT = new IdentifierDomain(new String(id) ); :}

          
          | INT LPAREN expression:e1 DOTDOT expression:e2 RPAREN
             {: 
                RESULT = new BoundedExpressionRange( (Expression) e1,
                                                     (Expression) e2);
             
             :}

          | INT LPAREN expression_list:e_list RPAREN 
            {: 
            	RESULT = new SparseExpressionRange((ArrayList<Expression>) e_list);
            :}
          

	      | MATRIX_INDEXED_BY LBRACK domain_list:d_list RBRACK OF domain:d
             {:  
				RESULT = new ArrayDomain( (Domain) d,
				                          (ArrayList<Domain>) d_list) ;

              :}
;


domain_list ::= domain:d
		    {: 
		       ArrayList<Domain> list = new ArrayList<Domain>();
		      list.add((Domain)  d); 
		      RESULT = list; 
		    :}

              | domain_list:d_list COMMA domain:d
		   {: 
		       ((ArrayList<Domain>) d_list).add( (Domain)  d); 
		       RESULT = d_list; 
		    :}
;



expression_list ::=  	  expression:e
				{: ArrayList<Expression> e_list = new ArrayList<Expression>();	
				   e_list.add(0,(Expression) e); 
				   RESULT = e_list; 
				:}

			| expression:e COMMA expression_list:e_list
				{: ((ArrayList<Expression>) e_list).add(0,(Expression) e); 
				   RESULT = e_list;
				:}
			| expression:e error expression_list:e_list 
			    {:
			       //((ArrayList<Expression>) e_list).add(0,(Expression) e); 
				   //RESULT = e_list;
				   String errMessage = "Detected parse error around the expression '"+e+
				   	"'\nMaybe missing comma after constraint?";
				   errorMessage.append(errMessage);
				   parser.errorMessage.append("\n"+errMessage);
				   parser.hadErrorRecovery = true;
				   //parser.setErrorRecovery(true);
				   //System.err.println(errMessage);
				   //parser.report_error(errMessage, e);
				   ((ArrayList<Expression>) e_list).add(0,(Expression) e); 
				   RESULT = e_list;
				   //throw new Exception("Parse error: "+errMessage);
			    :}
;



expression ::= 	  LPAREN expression:e RPAREN
			{: RESULT = e; :}
 			
	      	| atomic_expression:ae
			{: RESULT = ae; :}

     		| deref_expression:de
			{: RESULT = de; :}
  
	 	    | unary_expression:ue
	 		{: RESULT = ue; :}
	
		    | binary_expression:be
			{: RESULT = be; :}

		    | global_constraint:g
			{: RESULT = g; :}

		    | quantified_expression:qe
			{: RESULT = qe; :}
			
	    	| lex_expression:le
		    {: RESULT = le;  :}
		    
		 /*   |  table_constraint:tab_constraint
	        {: RESULT = tab_constraint;:}	
	       
	     */
	        
	   /*
	    | ATLEAST LPAREN expression:e1 COMMA LBRACK integer_list:int_list1 RBRACK COMMA LBRACK integer_list:int_list2 RBRACK RPAREN
	       
		{: 
		   Object[] tmp1 = ((LinkedList) int_list1).toArray();
		   int[] int_array1 = new int[tmp1.length];
		   for(int i=0;i<int_array1.length;i++)
 				int_array1[i] = (Integer) tmp1[i];
 				          
 	       Object[] tmp2 = ((LinkedList) int_list2).toArray();
		   int[] int_array2 = new int[tmp2.length];
		   for(int i=0;i<int_array2.length;i++)
 				int_array2[i] = (Integer) tmp2[i];
 				
		   RESULT = new Expression( new AtmostConstraint((Expression) e1,
									                     int_array1,
									                     int_array2,
									                     false)); //isAtmost =false :}	


		| ATMOST LPAREN expression:e1 COMMA LBRACK integer_list:int_list1 RBRACK COMMA LBRACK integer_list:int_list2 RBRACK RPAREN
		{: 
		   Object[] tmp1 = ((LinkedList) int_list1).toArray();
		   int[] int_array1 = new int[tmp1.length];
		   for(int i=0;i<int_array1.length;i++)
 				int_array1[i] = (Integer) tmp1[i];
 				          
 	       Object[] tmp2 = ((LinkedList) int_list2).toArray();
		   int[] int_array2 = new int[tmp2.length];
		   for(int i=0;i<int_array2.length;i++)
 				int_array2[i] = (Integer) tmp2[i];
 				
		   RESULT = new Expression( new AtmostConstraint((Expression) e1,
									                     int_array1,
									                     int_array2,
									                     true)); //isAtmost =true :}	
    */
;


atomic_expression ::=  INTEGER:i 
				{: 
				  RESULT = new ArithmeticAtomExpression(i); :}

	        	| TRUE
				{: RESULT = new RelationalAtomExpression(true); :}

				| FALSE 
				{: RESULT = new RelationalAtomExpression(false); :}

			   | IDENTIFIER:id
			    {: RESULT = new SimpleVariable(new String(id)); :}
;



deref_expression ::= 	IDENTIFIER:id LBRACK index_list:e_list RBRACK
               	        {:  
							RESULT = new SimpleArrayVariable(new String(id), 
							                                 (ArrayList<Domain>) e_list); 
							                                   
								                           
					    :}
;


index ::=      DOTDOT 
               {: RESULT = new InfiniteDomain(); :}
               
             | DOTDOT expression:e 
               {: 
                  boolean isLowerBound = false;
                  RESULT = new InfiniteDomain( (Expression) e, isLowerBound);
                :}
               
             | expression:e DOTDOT
               {:  
                   boolean isLowerBound = true;
                   RESULT = new InfiniteDomain( (Expression) e, isLowerBound);
                :}
             
             | expression:e1 DOTDOT expression:e2
               {: RESULT = new BoundedExpressionRange( (Expression) e1, (Expression) e2); :}
             
             | expression:e 
               {: RESULT = new SingleExpressionRange( (Expression) e); :}
             
             | LPAREN expression_list:e_list RPAREN
               {: 
		         RESULT = new SparseExpressionRange( (ArrayList<Expression>) e_list);
               :}
;             


index_list ::=   index:i 
                 {: 
                    ArrayList<Domain> e_list = new ArrayList<Domain>();	
				     e_list.add(0, (Domain) i); 
				     RESULT = e_list;   :}
				   
                 |   index:i COMMA index_list:i_list 
                 {: 
                   ((ArrayList<Domain>) i_list).add(0, (Domain)  i); 
				     RESULT = i_list;  
				 :}
;                 


atom_expression ::= deref_expression:deref
                     {: RESULT = deref; :} 

                   |  IDENTIFIER:id
				     {: RESULT = new SimpleVariable(new String(id)); :}
;



unary_expression ::= 	MINUS expression:e 
		           	    {: RESULT = new UnaryMinus((Expression) e); :} 
	      		      	 %prec UMINUS   

		               | BAR expression:e BAR
				         {: RESULT = new AbsoluteValue( (Expression) e); :}

			           | NOT expression:e
				         {: RESULT = new Negation( (Expression) e); :}
;



binary_expression ::=  expression:e1 EQ expression:e2
			{: RESULT =  new CommutativeBinaryRelationalExpression( (Expression) e1, 
			                                                         Expression.EQ,
			                                                        (Expression) e2 ); 
			:}

			| expression:e1 NEQ expression:e2
			{: RESULT =  new CommutativeBinaryRelationalExpression( (Expression) e1, 
			                                                         Expression.NEQ,
			                                                        (Expression) e2 ); 
			:}
			
			| expression:e1 LESS expression:e2
			{: RESULT =  new NonCommutativeRelationalBinaryExpression( (Expression) e1, 
			                                                         Expression.LESS,
			                                                        (Expression) e2 ); 
			:}
			
			| expression:e1 LEQ expression:e2
			{: RESULT =  new NonCommutativeRelationalBinaryExpression( (Expression) e1, 
			                                                         Expression.LEQ,
			                                                        (Expression) e2 ); 
			:}
			
			| expression:e1 GREATER expression:e2
			{: RESULT =  new NonCommutativeRelationalBinaryExpression( (Expression) e1, 
			                                                         Expression.GREATER,
			                                                        (Expression) e2 ); 
			:}
			
			| expression:e1 GEQ expression:e2
			{: RESULT =  new NonCommutativeRelationalBinaryExpression( (Expression) e1, 
			                                                         Expression.GEQ,
			                                                        (Expression) e2 ); 
			:}
                        
            | expression:e1 PLUS expression:e2	
			{: RESULT = new Sum ( new Expression[] { (Expression) e1, (Expression) e2 },
								  new Expression[] {} 
								 ); 
			:}

			| expression:e1 MINUS expression:e2
			{: RESULT = new Sum ( new Expression[] {(Expression) e1} ,
								  new Expression[] {(Expression) e2 } 
								 ); 
			:}

			| expression:e1 MULT expression:e2
			{: RESULT = new Multiplication (new Expression[] { (Expression) e1, (Expression) e2} 
			                                );
		     :}

			| expression:e1 DIVISION expression:e2
			{: RESULT = new NonCommutativeArithmeticBinaryExpression( (Expression) e1, 
			                                                           Expression.DIV, 
			                                                           (Expression) e2
			                                                         ); 
			                                          
			:}

			| expression:e1 POWER expression:e2
			{: RESULT = new NonCommutativeArithmeticBinaryExpression( (Expression) e1, 
			                                                           Expression.POWER, 
			                                                           (Expression) e2
			                                                         ); 
			                                          
			:}
			
			| expression:e1 MODULO expression:e2
			{: RESULT = new NonCommutativeArithmeticBinaryExpression( (Expression) e1, 
			                                                           Expression.MOD, 
			                                                           (Expression) e2
			                                                         ); 
			                                          
			:}
			
			| expression:e1 AND expression:e2
			{: RESULT = new Conjunction( new Expression[] { (Expression) e1, (Expression) e2 }); :}


			| expression:e1 OR expression:e2
			{: RESULT = new Disjunction( new Expression[] { (Expression) e1, (Expression) e2 }); :}

			| expression:e1 IF expression:e2
			{: RESULT =  new NonCommutativeRelationalBinaryExpression( (Expression) e1, 
			                                                         Expression.IF,
			                                                        (Expression) e2 ); 
			:}

			| expression:e1 IFF expression:e2
			{: RESULT =  new CommutativeBinaryRelationalExpression( (Expression) e1, 
			                                                         Expression.IFF,
			                                                        (Expression) e2 ); 
			:}
;



global_constraint ::= ALLDIFF LPAREN atom_expression:e RPAREN
					{: RESULT = new AllDifferent( (Expression) e); :}

			       | ALLDIFF LPAREN variable_array:va RPAREN 
			        {: RESULT = new AllDifferent( (VariableArray) va); :}
			        
			  	   | MIN LPAREN variable_array:va RPAREN
					{: 
					  boolean isMaximum = false;
					  RESULT = new Minimum( (Expression) va,
					                         isMaximum ); 
					 :}

				   | MAX LPAREN variable_array:va RPAREN
			  		{: 
					  boolean isMaximum = true;
					  RESULT = new Minimum( (Expression) va,
					                         isMaximum ); 
					 :}

	                                                   
	               | ELEMENT LPAREN expression:e1 COMMA expression:e2 COMMA expression:e3 RPAREN
	                 {: RESULT = new ElementConstraint( (Expression) e1,
	                									(Expression) e2,
	                									(Expression) e3);   
	                 :}	   									

		           | ATMOST LPAREN expression:e COMMA IDENTIFIER:occ COMMA IDENTIFIER:val RPAREN 
		             {: 
		                boolean isAtmost = true;
		                RESULT = new Atmost((Expression) e, 
		                                     (String) occ,
		                                     (String) val,
		                                      isAtmost 
		                                    );
		             
		             :}
		             
		           | ATLEAST LPAREN expression:e COMMA IDENTIFIER:occ COMMA IDENTIFIER:val RPAREN 
		             {: 
		                boolean isAtmost = false;
		                RESULT = new Atmost((Expression) e, 
		                                     (String) occ,
		                                     (String) val,
		                                      isAtmost 
		                                    );
		             :}
		             
		             
		             /*
		             | ATMOST LPAREN expression:e COMMA LBRACK integer_list:occ_list RBRACK COMMA IDENTIFIER:val RPAREN 
		             {: 
		             	int[] occList = new int[( (ArrayList<Integer>) occ_list).size()];
		             	
		             	for(int i=occList.length-1; i>=0; i--) 
		             		occList[i] = (int) ( (ArrayList<Integer>) occ_list ).remove(i);
		             		
		             	
		             
		                boolean isAtmost = true;
		                RESULT = new Atmost((Expression) e, 
		                                     occList,
		                                     (String) val,
		                                      isAtmost 
		                                    );
		             
		             :}
		             
		           | ATLEAST LPAREN expression:e COMMA LBRACK integer_list:occ_list RBRACK COMMA IDENTIFIER:val RPAREN 
		             {: 
		             	int[] occList = new int[( (ArrayList<Integer>) occ_list).size()];
		             	
		             	for(int i=occList.length-1; i>=0; i--) 
		             		occList[i] = (int) ( (ArrayList<Integer>) occ_list ).remove(i);
		             		
		             	
		             
		                boolean isAtmost = false;
		                RESULT = new Atmost((Expression) e, 
		                                     occList,
		                                     (String) val,
		                                      isAtmost 
		                                    );
		             
		             :}
		             
		             | ATMOST LPAREN expression:e COMMA IDENTIFIER:occ COMMA LBRACK integer_list:val_list RBRACK RPAREN 
		             {: 
		             	int[] valList = new int[( (ArrayList<Integer>) val_list).size()];
		             	
		             	for(int i=valList.length-1; i>=0; i--) 
		             		valList[i] = (int) ( (ArrayList<Integer>) val_list ).remove(i);
		             		
		             	
		             
		                boolean isAtmost = true;
		                RESULT = new Atmost((Expression) e, 
		                                     (String) occ,
		                                     valList,
		                                      isAtmost 
		                                    );
		             
		             :} 
		             
		             
		              | ATLEAST LPAREN expression:e COMMA IDENTIFIER:occ COMMA LBRACK integer_list:val_list RBRACK RPAREN 
		             {: 
		             	int[] valList = new int[( (ArrayList<Integer>) val_list).size()];
		             	
		             	for(int i=valList.length-1; i>=0; i--) 
		             		valList[i] = (int) ( (ArrayList<Integer>) val_list ).remove(i);
		             		
		             	
		             
		                boolean isAtmost = false;
		                RESULT = new Atmost((Expression) e, 
		                                     (String) occ,
		                                     valList,
		                                      isAtmost 
		                                    );
		             
		             :} 
		            
		            
		            
	               | ATMOST LPAREN expression:e COMMA LBRACK integer_list:int_list1 RBRACK COMMA LBRACK integer_list:int_list2 RBRACK RPAREN 
		             {: 
		             	int[] occList = new int[( (ArrayList<Integer>) int_list1).size()];
		             	int[] valList = new int[( (ArrayList<Integer>) int_list2).size()];
		             	
		             	for(int i=occList.length-1; i>=0; i--) 
		             		occList[i] = (int) ( (ArrayList<Integer>) int_list1 ).remove(i);
		             		
		             	for(int i=valList.length-1; i>=0; i--) 
		             		valList[i] = (int) ( (ArrayList<Integer>) int_list2 ).remove(i);
		             	
		             
		                boolean isAtmost = true;
		                RESULT = new Atmost((Expression) e, 
		                                     occList,
		                                     valList,
		                                      isAtmost 
		                                    );
		             
		             :}
		             
		          | ATLEAST LPAREN expression:e COMMA LBRACK integer_list:int_list1 RBRACK  COMMA LBRACK integer_list:int_list2 RBRACK RPAREN 
		             {: 
		             	int[] occList = new int[( (ArrayList<Integer>) int_list1).size()];
		             	int[] valList = new int[( (ArrayList<Integer>) int_list2).size()];
		             	
		             	for(int i=occList.length-1; i>=0; i--) 
		             		occList[i] = (int) ( (ArrayList<Integer>) int_list1 ).remove(i);
		             		
		             	for(int i=valList.length-1; i>=0; i--) 
		             		valList[i] = (int) ( (ArrayList<Integer>) int_list2 ).remove(i);
		             	
		             
		                boolean isAtmost = false;
		                RESULT = new Atmost((Expression) e, 
		                                     occList,
		                                     valList,
		                                      isAtmost 
		                                    );
		             
		             :}  */
		            
		            
		            | ATMOST LPAREN expression:e COMMA LBRACK expression_list:list1 RBRACK COMMA LBRACK expression_list:list2 RBRACK RPAREN 
		             {: 
					    boolean isAtmost = true;
		                RESULT = new Atmost((Expression) e, 
		                                     (ArrayList<Expression>) list1,
		                                     (ArrayList<Expression>) list2,
		                                      isAtmost 
		                                    );
		             
		             :}
	           
	               | ATLEAST LPAREN expression:e COMMA LBRACK expression_list:list1 RBRACK COMMA LBRACK expression_list:list2 RBRACK RPAREN 
		             {: 
					    boolean isAtmost = false;
		                RESULT = new Atmost((Expression) e, 
		                                     (ArrayList<Expression>) list1,
		                                     (ArrayList<Expression>) list2,
		                                      isAtmost 
		                                    );
		             
		             :} 
	           
;



variable_array ::=  LBRACK atom_list:list  RBRACK
                    {:  
                    	RESULT = new VariableArray( (ArrayList<AtomExpression>) list);  
                    
                    :} 
                   /* | LBRACK expression_list:list RBRACK
                    {:  
                    	RESULT = new VariableArray( (ArrayList<AtomExpression>) list);  
                    
                    :}   // TEST ONLY!!! */
;                    
                    


lex_expression ::=   expression:e1  LEXLESS expression:e2 
                     {: 
                        RESULT = new LexConstraint( (Expression) e1, 
                                                     Expression.LEX_LESS, 
                                                    (Expression) e2); 
                      :}
                     
                     
                     | expression:e1  LEXGREATER expression:e2 
                     {: 
                        RESULT = new LexConstraint( (Expression) e1, 
                                                     Expression.LEX_GREATER, 
                                                    (Expression) e2); 
                      :}
                      
                     | expression:e1  LEXLEQ expression:e2 
                     {: 
                        RESULT = new LexConstraint( (Expression) e1, 
                                                     Expression.LEX_LEQ, 
                                                    (Expression) e2); 
                      :}
                      
                     | expression:e1  LEXGEQ expression:e2 
                     {: 
                        RESULT = new LexConstraint( (Expression) e1, 
                                                     Expression.LEX_GEQ, 
                                                    (Expression) e2); 
                      :}
;



quantified_expression ::= EXISTS identifier_list:id_list COLON domain:d DOT expression:e
			         	{: 
			         	  boolean isUniversal = false;
			         	  RESULT = new QuantifiedExpression(isUniversal, 
								                            (ArrayList<String>) id_list,
								                            (Domain) d, 
								                            (Expression) e); 
					    :}
					    
					    | FORALL identifier_list:id_list COLON domain:d DOT expression:e
			         	{: 
			         	  boolean isUniversal = true;
			         	  RESULT = new QuantifiedExpression(isUniversal, 
								                            (ArrayList<String>) id_list,
								                            (Domain) d, 
								                            (Expression) e); 
					    :}
					    
					    | SUM identifier_list:id_list COLON domain:d DOT expression:e
			         	{: 
			         	  RESULT = new QuantifiedSum((ArrayList<String>) id_list,
								                     (Domain) d, 
								                     (Expression) e); 
					    :}
;



/*
table_constraint ::= TABLE LPAREN variable_array:va COMMA LBRACK constant_tuple_list:t_list RBRACK  RPAREN
                   {:  
                  
                    AtomExpression[] variables = ((VariableArray) va).getVariables();
                    Variable[] vars = new Variable[variables.length];
                    
                    for(int i=0; i<variables.length; i++) {
                       if(variables[i].getType == Expression.INT_ARRAY_VAR) {
                          vars[i] = ((ArithmeticAtomExpression) variables[i]).getVariable();
                       } 
                       else if(variables[i].getType == Expression.BOOL_ARRAY_VAR) {
                          vars[i] = ((RelationalAtomExpression) variables[i]).getVariable();
                       } 
                       else report_error("Unfeasible argument for table constraint: "+va+". Expected a variable.");
                    }  	
  	
  	
  	               
  	               
  	               
  	
                   RESULT = new TableConstraint(vars,
                                                t_array);
                   :}

;
*/




atom_list ::=    atom_expression:atom 
               {: 
                  ArrayList<AtomExpression> list = new ArrayList<AtomExpression>();
				  list.add(0,(AtomExpression) atom);
				  RESULT = list; 
			    :}
				  
				  
                 | atom_expression:atom COMMA atom_list:a_list 
               {: 
                  ((ArrayList<AtomExpression>) a_list).add(0,(AtomExpression) atom); 
				  RESULT = a_list; 
			   :}                 
                      
;                 


/*
constant_tuple_list ::= constant_tuple:c_tuple
                         {: LinkedList list = new LinkedList();
				            list.add(0,(ConstantTuple) c_tuple);
				            RESULT = list; :}

                        | constant_tuple:c_tuple COMMA constant_tuple_list:t_list
                        {: ((LinkedList) t_list).add(0,(ConstantTuple) c_tuple); 
				            RESULT = t_list; :}
;                        
                        


constant_tuple ::= LESS  integer_list:int_list GREATER
                   {:
                   	Object[] tmp = ((LinkedList) int_list).toArray();
			        int[] int_array = new int[tmp.length];
			        for(int i=0;i<int_array.length;i++)
 				          int_array[i] = (Integer) tmp[i];
 				          
 				    RESULT = new ConstantTuple(int_array);     
                   :}
;                   
*/

integer_list ::=  INTEGER:i 
                 {: ArrayList<Integer> list = new ArrayList<Integer>();
				    list.add(0,(Integer) i);
				    RESULT = list;
                 :}
                 | MINUS INTEGER:i
                 {: ArrayList<Integer> list = new ArrayList<Integer>();
                    list.add(0,(Integer) (i-2*i));
                    RESULT = list;
                 :}
                 
                 | INTEGER:i COMMA  integer_list:int_list 
                {: ((ArrayList<Integer>) int_list).add(0,(Integer) i); 
				    RESULT = int_list; 
				 :}
				 
				  | MINUS INTEGER:i COMMA  integer_list:int_list 
                {: ((ArrayList<Integer>) int_list).add(0,(Integer) (i-2*i)); 
				    RESULT = int_list; 
				 :}
;


		


constant_vector ::=  LBRACK  integer_list:i_list  RBRACK
					{:   
					   RESULT = i_list;
					:}
;


constant_vector_list ::=  constant_vector:int_list  
                          {: 
                             ArrayList<ArrayList<Integer>> vectorList = new ArrayList<ArrayList<Integer>>();
                             vectorList.add(0, (ArrayList<Integer>) int_list);
                             RESULT = vectorList; :}
                          
                          |  constant_vector:vector  COMMA constant_vector_list:list
                          {:  
                             ArrayList<ArrayList<Integer>> vectorList = (ArrayList<ArrayList<Integer>>) list;
                             vectorList.add(0,(ArrayList<Integer>) vector);
                             RESULT = vectorList;
                          :}
;                          

constant_matrix ::= LBRACK constant_vector_list:list RBRACK
                    {:      
                      ArrayList<ArrayList<Integer>> vectorList = (ArrayList<ArrayList<Integer>>) list;     
                     ArrayList<Integer> vector0 =  vectorList.get(0);
                  
                     
                     Integer[][] matrix = new Integer[vectorList.size()][vector0.size()];
                   
                     for(int i=0; i<vectorList.size(); i++) {
                     
                        ArrayList<Integer> vector = vectorList.get(i);
                        
                        if(vector.size() != vector0.size()) 
                           throw new Exception("Illegal constant array: every vector/row has to have the same amount of elements!");
                        
                        for(int j=0; j<vector.size(); j++)
                           matrix[i][j] = (Integer) vector.get(j);
                     
                     }
                     
                      RESULT = matrix;
                    
                      :}
;

	

/*
user_def_type ::= ENUM LBRACE identifier_list:id_list RBRACE
               	        {:  Object[] tmp = ((LinkedList) id_list).toArray();	
	        	    Identifier[] id_array = new Identifier[tmp.length];
			    for(int i=0;i<id_array.length;i++)
 			   	 id_array[i] = (Identifier) tmp[i];

			    RESULT = new Type(new Enumeration(id_array)); :}
;


*/

